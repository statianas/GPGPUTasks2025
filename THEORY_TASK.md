# Теоретическое задание: параллелизуемость/code divergence/memory coalesced access

Ниже три небольших задачи. Рекомендуется хотя бы начать делать каждое задание к лекции 29 сентября, чтобы задать вопросы если они будут и обсудить задания.

Формат сдачи - письмо на ```gpucourse@yandex.ru```

- тема письма как название PR: ```Task02 <Имя Фамилия>```
- задания должны идти подряд - от первого к третьему
- явно должен быть виден ```ответ```
- должно быть объяснение ответа (рассуждение)
- форма может быть свободной - в т.ч. любые иллюстрации если они упрощают понимание (кроме фотографии рукописного текста)

**1)** Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

_**Решение:**_ Первый сигнал будет реализовать легче, поскольку в этом случае мы часто обращаемся к соседним элементам X в одном и том же буфере (-> coalesed доступ), нет рекурретной зависимости.
Во втором сигнале мы обращаемся к разным буферам + имеем рекурретную зависимость, которую будет трудно распараллелить.

**Ответ:** y1.

**2)** Предположим что размер warp/wavefront равен 32 и рабочая группа делится
на warp/wavefront-ы таким образом что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

**_Решение:_** Поскольку потоков в нашем варпе 32, `get_local_id(1)` (от 0 до 31) и `get_local_size(1)` (=32) будет фиксированным для всех потоков в варпе,  при этом `get_local_id(0)` может принимать значения так же от 0 до 31. Значение idx % 32 будет равно просто get_local_id(1), а тогда все потоки посетят только одну из веток if-else и code divergency не будет.

**Ответ:** нет.

**3)** Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
на warp/wavefront-ы таким образом что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**_Решение:_** Поскольку `get_local_size(1)` есть 32, `get_local_id(1)` фиксирован для каждого варпа (и принимает значения от 0 до 31), а `get_local_id(0)` бегает от 0 до 31, то наши потоки будут обращаться последовательно к данным окном размера 32, поэтому имеем coalesced доступ. А поскольку 1 float = 4 байта -> 32 потока x 4 байта = 128 байт подряд, нам каждый раз будут приносить одну кеш-линию. В рабочей группе 32 варпа, значит и кэш-линий будет 32.

**Ответ:** да, 32.


(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**_Решение:_** В данном случае у нас будет бегать один из множителей `get_local_id(0)`, а остальные элементы буду фиксированы, тогда каждый поток должен будет рассматривать элемент, находящийся на расстоянии 32 элемента от предыдущего, это означает, что каждому потоку нужна будет своя кэш-линия ->  coalesced доступа не будет. Всего кэш-линий нам должны будут принести 32*32, поскольку в рабочей группе 32 варпа.

**Ответ:** нет, 32*32.

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**_Решение:_** Для каждого варпа в данном случае нужно будет принести 2 кэш-линии (поскольку последний поток должен рассматривать элемент из следующей кэш-линии). Доступ, как и в первом случае, остается coalesced, поскольку мы также рассматриваем элементы последовательно. Всего кэш-линий в рамках одной рабочей группы будет 32*2=64.

**Ответ:** да, 64.